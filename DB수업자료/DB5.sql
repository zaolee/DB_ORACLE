SELECT * FROM DEPT;

INSERT INTO DEPT VALUES(10, 'TEST', SEOUL); -- 'UNIQUE' 제약조건 위반

DESC DEPT;

DESC USER_CONSTRAINTS;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT';
-- TYPE -> P : PRIMARY 타입

-- NOT NULL 제약 조건을 설정하지 않고 테이블 생성하기
DROP TABLE EMP01;
CREATE TABLE EMP01(
        EMPNO NUMBER(4),
        ENAME VARCHAR2(10),
        JOB VARCHAR2(9),
        DEPTNO NUMBER(2)
);
SELECT * FROM EMP01;
INSERT INTO EMP01 VALUES(NULL, NULL, 'SALESMAN', 30);

-- NOT NULL 제약 조건을 설정하여 테이블 생성하기
DROP TABLE EMP02;
CREATE TABLE EMP02(
        EMPNO NUMBER(4) NOT NULL,
        ENAME VARCHAR2(10) NOT NULL,
        JOB VARCHAR(9),
        DEPTNO NUMBER(2)
);        
INSERT INTO EMP02 VALUES(NULL, NULL, 'SALESMAN', 30); 
-- cannot insert NULL into ("SCOTT"."EMP02"."EMPNO") -> NULL을 넣을수 없어요
INSERT INTO EMP02 VALUES(10, '소연', 'SALESMAN', 30); 
SELECT * FROM EMP02;
        
-- UNIQUE 제약 조건을 설정하여 테이블 생성하기
DROP TABLE EMP03;
CREATE TABLE EMP03(
        EMPNO NUMBER(4) CONSTRAINT EMP_EMPNO_UQ UNIQUE,
        ENAME VARCHAR2(10) NOT NULL,
        JOB VARCHAR2(9),
        DEPTNO NUMBER(2)
);
INSERT INTO EMP03 VALUES(7499, 'ZAO', 'SALEMAN', 30);
SELECT * FROM EMP03;
INSERT INTO EMP03 VALUES(7499, 'LEE', 'MANAGER', 20);
-- unique constraint (SCOTT.SYS_C007028) violated -> 'UNIQUE' 조건으로 똑같은 EMPNO가 올수 없어
-- unique constraint (SCOTT.EMP_EMPNO_UQ) violated -> 제약 조건명 설정함
INSERT INTO EMP03 VALUES(NULL, 'LEE', 'MANAGER', 20);
INSERT INTO EMP03 VALUES(NULL, 'LEEE', 'MANAGER', 20);
INSERT INTO EMP03 VALUES(NULL, 'LEEEE', 'MANAGER', 20); 
-- 'UNIQUE' 조건에는 다수의 NULL이 들어갈 수 있음.(어차피 모르는 값이라)
-- 하지만 'UNIQUE'자체가 NULL이 들어가면 안되는 경우가 많아서 'NOT NULL'이랑 같이 다님

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP03';
-- EMP03의 제약조건명 출력해주실?

-- PRIMARY KEY(PK, 기본키) 제약조건 설정하기
DROP TABLE EMP05;
CREATE TABLE EMP05(
        EMPNO NUMBER(4) CONSTRAINT EMP05_EMPNO_PK PRIMARY KEY,
        ENAME VARCHAR2(10) CONSTRAINT EMP05_ENAME_NN NOT NULL,
        JOB VARCHAR2(9),
        DEPTNO NUMBER(2)
);
INSERT INTO EMP05 VALUES(7499, 'ALLEN', 'SALESMAN', 30);
SELECT * FROM EMP05;
INSERT INTO EMP05 VALUES(7499, 'ZAO', 'MANAGER', 20);
-- unique constraint (SCOTT.EMP05_EMPNO_PK) violated
INSERT INTO EMP05 VALUES(NULL, 'ZAO', 'MANAGER', 20);
-- cannot insert NULL into ("SCOTT"."EMP05"."EMPNO")

-- EMP, DEPT 테이블의 제약조건 확인
SELECT TABLE_NAME, CONSTRAINT_TYPE, CONSTRAINT_NAME, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('DEPT','EMP');

DROP TABLE EMP06;
CREATE TABLE EMP06(
        EMPNO NUMBER(4) CONSTRAINT EMP06_EMPNO_PK PRIMARY KEY,
        ENAME VARCHAR2(10) CONSTRAINT EMP06_ENAME_NN NOT NULL,
        JOB VARCHAR2(9),
        DEPTNO NUMBER(2) CONSTRAINT EMP06_DEPTNO_FK REFERENCES DEPT(DEPTNO)
);
INSERT INTO EMP06 VALUES(7499, 'ZAO', 'SALESMAN', 30);
SELECT * FROM EMP06;
INSERT INTO EMP06 VALUES(7498, 'LEE', 'MANAGER', 50);
--  integrity constraint (SCOTT.EMP06_DEPTNO_FK) violated - parent key not found
-- DEPT(DEPTNO)에는 50이 없기 때문에 오류발생(FK로 테이블과 테이블 관계 연결 시켜놓은거)

-- CHECK 제약 조건 설정하기
DROP TABLE EMP07;
CREATE TABLE EMP07(
        EMPNO NUMBER(4) CONSTRAINT EMP07_EMPNO_PK PRIMARY KEY,
        ENAME VARCHAR2(10) CONSTRAINT EMP07_ENAME_NN NOT NULL,
        SAL NUMBER(7,2) CONSTRAINT EMP07_SAL_CK CHECK(SAL BETWEEN 500 AND 5000),
        GENDER VARCHAR2(1) CONSTRAINT EMP07_GENDER_CK CHECK(GENDER IN('M', 'F'))
);
INSERT INTO EMP07 VALUES(7499, 'ZAO', 500, 'F');
INSERT INTO EMP07 VALUES(7498, 'LEE', 700, 'A');
-- check constraint (SCOTT.EMP07_GENDER_CK) violated -> GENDER 은 'M' 아님 'F'만 넣기 가능
-- CHECK는 우리가 원하는 조건을 도출하기 위해 거는 제약조건

SELECT TABLE_NAME,CONSTRAINT_TYPE, CONSTRAINT_NAME, SEARCH_CONDITION
FROM USER_CONSTRAINTS
WHERE TABLE_NAME= 'EMP07';
-- SEARCH_CONDITION : 내가 무슨 제약조건 넣었는지.

-- DEFAULT 제약 조건 설정하기
DROP TABLE DEPT01;
CREATE TABLE DEPT01(
        DEPTNO NUMBER(2) PRIMARY KEY,
        DNAME VARCHAR2(14),
        LOC VARCHAR2(13) DEFAULT 'SEOUL'
);
INSERT INTO DEPT01(DEPTNO, DNAME) VALUES (10, 'ACCOUNTING');
-- 기존에 LOC를 지정안하고 값을 입력안하면 알아서 NULL로 들어갔는데 
-- 우리는 제약조건에 LOC 값에 SEOUL로 넣으라고 지정해놓음, 만약 LOC에 값을 넣으면 해당 값으로 들어감
INSERT INTO DEPT01 VALUES(20, 'RESEARCH', 'BUSAN'); -- LOC값에 'BUSAN' 들어감
SELECT * FROM DEPT01;
        
-- 컬럼 레벨로 제약조건을 지정하기
DROP TABLE EMP01;
CREATE TABLE EMP01(
        EMPNO NUMBER(4) PRIMARY KEY,
        ENAME VARCHAR2(10) NOT NULL,
        JOB VARCHAR2(9) UNIQUE,
        DEPTNO NUMBER(4) REFERENCES DEPT(DEPTNO)
);

-- 테이블 레벨로 제약조건 지정하기
DROP TABLE EMP02;
CREATE TABLE EMP02(
        EMPNO NUMBER(4),
        ENAME VARCHAR2(10) NOT NULL,
        JOB VARCHAR2(9),
        DEPTNO NUMBER(4),
        PRIMARY KEY(EMPNO),
        UNIQUE(JOB),
        FOREIGN KEY(DEPTNO) REFERENCES DEPT(DEPTNO) -- 이렇게 테이블 레벨로 제약조건 지정
);

-- CASCADE 옵션으로 제약 조건 연속적으로 비활성하기
-- DROP TABLE DEPT01 CASCADE CONSTRAINTS; 
-- DEPT01을 참조하고 있는 자식테이블이 있다면 지울수 없어서 저렇게 해주는거
DROP TABLE DEPT01;
CREATE TABLE DEPT01
AS
SELECT * FROM DEPT;
SELECT * FROM DEPT01;
DESC DEPT01; -- 제약조건은 복사 안됨

ALTER TABLE DEPT01
ADD CONSTRAINT DEPT01_DEPTNO_PK PRIMARY KEY (DEPTNO); -- 테이블 레벨 방식으로 제약조건 추가
DESC DEPT01;

DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT * FROM EMP WHERE 1=0; -- 테이블 구조만 가져옴
SELECT * FROM EMP01;
DESC EMP01;

ALTER TABLE EMP01
ADD CONSTRAINT EMP1_DEPTNO_FK FOREIGN KEY(DEPTNO) REFERENCES DEPT01(DEPTNO);
-- ON DELETE CASCADE;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE,TABLE_NAME, R_CONSTRAINT_NAME, STATUS
FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN('DEPT01', 'EMP01');

SELECT * FROM DEPT01;
SELECT * FROM EMP01; -- DEPTNO을 부모DEPT01을 참조하고 있음

INSERT INTO EMP01(DEPTNO) VALUES(10); -- DEPTNO에만 값 10 넣어줌. 나머지는 NULL

DELETE FROM DEPT01
WHERE DEPTNO = 10; --부모 DEPT01에 있는 10 지울게~
-- integrity constraint (SCOTT.EMP1_DEPTNO_FK) violated - child record found
-- 응 못지워~ 자식(EMP01)에서 쓰고 있걸랑
-- 지우려면 자식에 쓰고 있는 DEPTNO 지우고 지워~ : 마음대로 못지움, 자식 또 언제 찾고 언제 지우는데 ㅡㅡ
-- 여기서, 자식을 만들때 옵션 넣어주면 됨

ALTER TABLE EMP01
ADD CONSTRAINT EMP1_DEPTNO_FK FOREIGN KEY(DEPTNO) REFERENCES DEPT01(DEPTNO)
ON DELETE CASCADE; -- 추가해줌

INSERT INTO EMP01(DEPTNO) VALUES(10); -- 10 넣어주고

DELETE FROM DEPT01
WHERE DEPTNO = 10; -- 10 지워 -> 가능
-- 부모꺼를 지우니까 자식에서 쓰고 있던건도 알아서 싸악 지워짐. 굳이 하나하나 자식 찾아서 지우고 이런거 하기싫을때 이거 사용
-- 대신 위험성은 있으니 조심하기~(선택사항,옵션)

DROP TABLE DEPT01; -- 이것도 CASCADE CONSTRAINTS없으면 마음대로 지울수 없음
DROP TABLE DEPT01 CASCADE CONSTRAINTS; -- 이런식으로 써줘야 아에 삭제 가능
SELECT * FROM DEPT01;
SELECT * FROM EMP01;

-- 가상테이블인 뷰
SELECT * FROM EMP;
SELECT EMPNO, ENAME FROM EMP;
SELECT * FROM EMP
WHERE DEPTNO=10;

-- 뷰의 기본 테이블 생성하기
DROP TABLE DEPT_COPY;
CREATE TABLE DEPT_COPY
AS
SELECT * FROM DEPT;

SELECT * FROM DEPT_COPY; -- 뷰의 기본 테이블 생성

DROP TABLE EMP_COPY;
CREATE TABLE EMP_COPY
AS
SELECT * FROM EMP;
SELECT * FROM EMP_COPY; -- 뷰의 기본 테이블 생성

-- 뷰 정의하기
CREATE VIEW EMP_VIEW30
AS
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP_COPY
WHERE DEPTNO=30; -- SYSTEM에서 SCOTT한테 뷰 생성할 수  있는 권한 부여함.
-- SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP_COPY
-- WHERE DEPTNO=30;
-- 이부분을 자주 사용할수도 있으니까, 가상 뷰로 만드는거얌

--GRANT CREATE VIEW TO SCOTT;
-- SYSTEM계정(워크시트)에서 SCOTT한테 뷰생성할 수 있는 권한 부여

SELECT * FROM EMP_VIEW30; -- 테이블 같아보이지만, 아님 뷰 생성해서 우리가 원하는 거 바로바로 치기 쉽게!

-- 단순 뷰의 컬럼에 별칭 부여하기
DESC EMP_VIEW30; -- 4개의 컬럼으로 이뤄진 가상 뷰
CREATE VIEW EMP_VIEW(사원번호, 사원명, 부서번호)
AS 
SELECT EMPNO, ENAME, DEPTNO
FROM EMP_COPY;
SELECT * FROM EMP_COPY;

SELECT * FROM EMP_VIEW;

-- 복합 뷰의 만들기
DROP VIEW EMP_VIEW_DEPT;
CREATE VIEW EMP_VIEW_DEPT
AS
SELECT E.EMPNO 사원번호, E.ENAME 사원명, E.SAL 연봉, E.DEPTNO 부서번호, D.DNAME 부서명, D.LOC 지역 -- 이렇게 쿼리문으로 만들어서 생성
FROM EMP E, DEPT D -- 두개의 테이블 이용
WHERE E.DEPTNO = D.DEPTNO 
ORDER BY EMPNO DESC;

SELECT*FROM EMP_VIEW_DEPT;
-- 이 형식을 내가 이제 바로바로 넣어서 쓰고 싶을때 이 뷰를 쓰면 되는거임. 개꿀

-- 뷰 삭제하기
SELECT VIEW_NAME, TEXT
FROM USER_VIEWS; -- 만들어진 뷰 보기

DROP VIEW EMP_VIEW; -- 제거됨
-- 뷰는 서브 쿼리문으로 만들어서 사용하는거!! 복잡한 쿼리 문을 아주 간단하게 테이블처럼 쓸수 있게 만드는거 + 보안

-- 뷰 옵션
-- 뷰 변경하고 싶을땐? -> DROP해서 변경해서 다시 생성 -> 최악;;;
-- 아에 OR RELACE 옵션 붙이기
CREATE OR REPLACE VIEW EMP_VIEW_DEPT
AS
SELECT E.EMPNO 사원번호, E.ENAME 사원명, E.DEPTNO 부서번호, D.DNAME 부서명, D.LOC 지역 -- 이렇게 쿼리문으로 만들어서 생성
FROM EMP E, DEPT D -- 두개의 테이블 이용
WHERE E.DEPTNO = D.DEPTNO 
ORDER BY EMPNO DESC; -- 수정 가능(기존에 있는거) 없으면 새로 생성되는거고

SELECT*FROM EMP_VIEW_DEPT;

-- 기본 테이블 없이 뷰를 생성하고 싶을때
-- FORCE 옵션
CREATE OR REPLACE VIEW EMPLOYEES_VIEW
AS
SELECT EMPNO, ENAME, DEPTNO
FROM EMPLOYEES -- EMPLOYEES 존재하지 않는 테이블임
WHERE DEPTNO=30;
-- table or view does not exist
CREATE OR REPLACE FORCE VIEW EMPLOYEES_VIEW -- FORCE 넣어주기
AS
SELECT EMPNO, ENAME, DEPTNO
FROM EMPLOYEES -- EMPLOYEES 존재하지 않는 테이블임
WHERE DEPTNO=30;

SELECT VIEW_NAME, TEXT
FROM USER_VIEWS; -- 보면 EMPLOYEES_VIEW가 생김 ㅋ, 강제로 만든다고 생각하면 편할듯

-- WHIT CHECK OPTION
-- 뷰를 생성할 때 조건 제시에 사용된 컬럼값을 변경하지 못하게 하는 기능
CREATE OR REPLACE VIEW VIEW_CHK30
AS
SELECT EMPNO, ENAME, SAL, COMM, DEPTNO
FROM EMP_COPY
WHERE DEPTNO=30 WITH CHECK OPTION;

SELECT * FROM VIEW_CHK30
WHERE DEPTNO=20; --생성할 때 DEPTNO = 30을 조건으로 걸었기 때문에 나오지 않음.

SELECT * FROM VIEW_CHK30;

UPDATE VIEW_CHK30
SET DEPTNO=20
WHERE SAL>=1200; -- 내용 수정할껀데 SAL>=1200인 애들 DEPTNO을 20으로 바꿔주실?
-- view WITH CHECK OPTION where-clause violation -> CHECK OPTION으로 오류남
-- 기존 WHERE조건으로 걸어둔걸 UPDATE하면 무시하게 되버리니까 그거 못하게 쓰는것
-- 뷰의 내용이 바뀌지 못하도록 저렇게 CHECK OPTION을 걸어두는것.

-- WITH READ ONLY 옵션
SELECT * FROM VIEW_CHK30; -- DEPT = 30이 들어가 있음
UPDATE VIEW_CHK30
SET DEPTNO=20;

SELECT * FROM EMP_COPY; -- 보면 여기까지 DEPTNO가 30인 애들까지 20으로 바뀌어져 버림

CREATE OR REPLACE VIEW VIEW_READ30
AS
SELECT EMPNO, ENAME, SAL, COMM, DEPTNO
FROM EMP_COPY
WHERE DEPTNO=30 WITH READ ONLY; -- ONLY 읽는 기능만 부여하는거임

UPDATE VIEW_READ30
SET DEPTNO=20;
--  WITH READ ONLY을 사용했기 때문에
-- cannot perform a DML operation on a read-only view -> 이렇게 에러남

SELECT * FROM VIEW_READ30;

-- ROWNUM 컬럼 성격 : 해당 테이블에 입력된 데이터의 입력된 순서를 나타냄.
SELECT ROWNUM, EMPNO, ENAME, HIREDATE
FROM EMP
ORDER BY ENAME ASC; -- ROWNUM 순서와 순서가 달라졍

-- 급여(SAL)를 많이 받는 6~10째 사원을 출력하기
SELECT ENAME, SAL
FROM EMP
ORDER BY SAL DESC; -- SAL많이 받는 순으로 했쭁

SELECT RNUM, ENAME, SAL -- 그거에 로우 넘, 사원명 급여 출력해주고
FROM (SELECT ROWNUM RNUM, ENAME, SAL -- 로우넘, 사원명, 급여 출력
        FROM (SELECT * FROM EMP ORDER BY SAL DESC)) --이 결과로 출력(급여 많은순)
WHERE RNUM BETWEEN 6 AND 10;        
-- SELECT * FROM EMP ORDER BY SAL DESC 이걸로 새로운 테이블로 만들어진것
-- 그래서 기존 EMP테이블과 ROWNUM이 다름
-- 이거 쓰는 이유 : 페이지 만들때 게시글이 2페이지에 ~번째부터 ~번째까지 출력할때 사용

-- 1. 사원 테이블(EMP)에서 가장 최근에 입사한 사원들중에 3~5번째의 사번과 사원명을 출력하는 SQL문을 작성하세요?
SELECT RNUM, ENAME 사원명, EMPNO 사원번호
FROM (SELECT ROWNUM RNUM, ENAME, EMPNO 
        FROM (SELECT * FROM EMP ORDER BY HIREDATE DESC)) 
WHERE RNUM BETWEEN 3 AND 5;       