SELECT * FROM DEPT01;
DESC DEPT01;
INSERT INTO DEPT01 VALUES (10, '총무부', '서울');
INSERT INTO DEPT01 (DEPTNO, DNAME) VALUES (20, '개발부'); -- 원하는 칼럼만 데이터 삽입, 빈공간은 암묵적으로 NULL이 됨

INSERT INTO DEPT01
(DEPTNO, DNAME, LOC) VALUES (30, 'ACCOUNTING', '서울'); -- VALUES의 개수 맞춰주기
INSERT INTO DEPT01 VALUES (40, '영업부', NULL); -- 넣은것이 없으면 NULL로 채워주기

-- 서브 쿼리로 데이터를 삽입하기
DROP TABLE DEPT02
CREATE TABLE DEPT02
AS
SELECT * FROM DEPT WHERE 1=0;
SELECT * FROM DEPT02;

INSERT  INTO DEPT02 
-- VALUES();
SELECT * FROM DEPT;
SELECT * FROM DEPT02;

-- 다중 테이블에 다중행 입력하기
DESC EMP
SELECT * FROM EMP
WHERE DEPTNO=20;
DROP TABLE EMP_HIR;
CREATE TABLE EMP_HIR
AS
SELECT EMPNO, ENAME, HIREDATE FROM EMP
WHERE 1=0;
SELECT * FROM EMP_HIR;
DROP TABLE EMP_MGR;
CREATE TABLE EMP_MGR
AS
SELECT EMPNO, ENAME, MGR FROM EMP
WHERE 1=0;
SELECT * FROM EMP_MGR;
INSERT ALL
INTO EMP_HIR VALUES(EMPNO, ENAME, HIREDATE)
INTO EMP_MGR VALUES(EMPNO, ENAME, MGR)
SELECT EMPNO, ENAME, HIREDATE, MGR
FROM EMP
WHERE DEPTNO=20;
SELECT * FROM EMP_HIR;
SELECT * FROM EMP_MGR;

-- UPDATE 문
DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT * FROM EMP;
SELECT * FROM EMP01
ORDER BY SAL ASC;

UPDATE EMP01
SET DETPNO = 30;

UPDATE EMP01
SET SAL = SAL * 1.1;
ROLLBACK;

UPDATE EMP01
SET HIREDATE = SYSDATE;

DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT * FROM EMP;
SELECT * FROM EMP01;

UPDATE EMP01
SET DEPTNO = 30
WHERE DEPTNO = 10; -- DEPTNO가 10인 사람들을 30으로 옮겨

UPDATE EMP01
SET SAL = SAL*1.1
WHERE SAL<3000;

UPDATE EMP01
SET HIREDATE = SYSDATE
WHERE SUBSTR(HIREDATE, 1, 2) = '87'; -- HIEREDATE에서 첫번째에서 두개 
SELECT * FROM EMP01;

-- 테이블에서 2개 이상의 컬럼값 변경
DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT * FROM EMP;
SELECT * FROM EMP01;

UPDATE EMP01
SET DEPTNO=20, JOB='MANAGER'
WHERE ENAME='SCOTT';

UPDATE EMP01
SET HIREDATE=SYSDATE, SAL=350, COMM=4000
WHERE ENAME='SCOTT';

-- 서브 쿼리를 이용한 데이터 수정하기
SELECT * FROM DEPT01;
UPDATE DEPT01
SET LOC=(SELECT LOC FROM DEPT WHERE DEPTNO=20);
-- SELECT LOC FROM DEPT WHERE DEPTNO=20 : DALLAS

-- DELETE 문
DELETE FROM DEPT01;
SELECT * FROM DEPT01;
ROLLBACK;

DELETE FROM DEPT01
WHERE LOC='서울';

DELETE FROM DEPT01
WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE DNAME = 'RESEARCH');

-- MERGE
DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT * FROM EMP; -- 카피해서 복사

SELECT * FROM EMP01; -- 모든직원이 존재

DROP TABLE EMP02;
CREATE TABLE EMP02
AS
SELECT * FROM EMP
WHERE JOB='MANAGER'; -- 카피해서 복사, 매니저만 복사할게~

SELECT * FROM EMP02; -- 매니저만 존재

UPDATE EMP02
SET JOB='TEST';
SELECT * FROM EMP02; -- 매니저 -> 테스트로 바뀜

INSERT INTO EMP02
VALUES(8000, 'SYJ', 'TOP', 7566, '2009/01/12', 1200, 10, 20); -- EMP02에 데이터 넣음, 기존데이터(3) + 신규데이터(1)

MERGE INTO EMP01 -- EMP01에 넣을게
-- 기존에(테스트로바뀐)데이터 들은 머지할때 업데이트를 해야되고, 신규데이터는 업데이트가 아닌, 인서트로 넣어야돼
USING EMP02
ON(EMP01.EMPNO=EMP02.EMPNO)-- 맵핑 시킴
WHEN MATCHED THEN -- 조건 : 매치가 되면
UPDATE SET -- 업데이트 가자
EMP01.ENAME=EMP02.ENAME,
EMP01.JOB=EMP02.JOB,
EMP01.MGR=EMP02.MGR,
EMP01.HIREDATE=EMP02.HIREDATE,
EMP01.SAL=EMP02.SAL,
EMP01.COMM=EMP02.COMM,
EMP01.DEPTNO=EMP02.DEPTNO

WHEN NOT MATCHED THEN -- 매치되지 않으면
INSERT VALUES(EMP02.EMPNO, EMP02.ENAME, EMP02.JOB, -- 인서트 가자
EMP02.MGR, EMP02.HIREDATE, EMP02.SAL,
EMP02.COMM, EMP02.DEPTNO);

SELECT * FROM EMP01;-- 기존 JOB이 메니저 -> 업데이트 -> TEST + 새로운 데이터 추가됨(INSERT)
SELECT * FROM EMP;
DESC EMP01; -- 조건없음(중복허용)
DESC EMP; -- EMPNO에 NOT NULL이라는 조건 있음.
-- EMPNO : 제약조건(PRIMARY KEY = NOT NULL(값이 있어야되고) + UNIQUE, 기본키)
INSERT INTO EMP01(EMPNO, ENAME) VALUES(7369, '쏘연'); -- 그럼 똑같은 7369가 두개 있는거
INSERT INTO EMP(EMPNO, ENAME) VALUES(7369, '쏘연'); 
-- unique constraint (SCOTT.PK_EMP) violated 에러남 그래서 새로운 삽입이 아닌 업데이트를 사용해야되는거!!
-- 그래서 MERGE를 사용하는 경우에는 나눠서 사용. 중복 나면 안되니까 기존 데이터가 있는 경우에는 UPDATE를 사용하고 아에 없는경우 INSERT를 사용

DROP TABLE DEPT01;
CREATE TABLE DEPT01
AS
SELECT * FROM DEPT;
SELECT * FROM DEPT01;

-- CREATE문에 의한 자동 커밋
DROP TABLE DEPT02;
CREATE TABLE DEPT02
AS
SELECT * FROM DEPT;
SELECT * FROM DEPT02;

DELETE FROM DEPT02
WHERE DEPTNO = 40;
ROLLBACK;

-- DDL문은 AUTO COMMIT 수행한다.
CREATE TABLE DEPT03
AS
SELECT * FROM DEPT; -- 이렇게 CREATE를 사용했기 때문에 AUTO COMMIT 수행됨
-- 그래서 이전에 수정내용을 롤백해도 이전으로 돌아가지 않아. 

-- DDL의 실패에 의한 자동 커밋
DROP TABLE DEPT03;
CREATE TABLE DEPT03
AS
SELECT * FROM DEPT;

SELECT * FROM DEPT03;

DELETE FROM DEPT03
WHERE DEPTNO=20;

ROLLBACK;

TRUNCATE TABLE DEPTPP; -- 존재하지 않은 테이블 삭체 요청 -> 에러
-- 이후 DEPT03을 롤백해서 보고 싶어도 볼수 없음.  비정상적인 접근으로 AUTO COMMIT 된거야

-- SAVEPOINT
DROP TABLE DEPT01;
CREATE TABLE DEPT01
AS
SELECT * FROM DEPT;
SELECT * FROM DEPT01;

DELETE FROM DEPT01
WHERE DEPTNO=40;
COMMIT; -- 다시는 복구 못함, 40을 지운거

DELETE FROM DEPT01
WHERE DEPTNO = 60;
SAVEPOINT C1;

DELETE FROM DEPT01
WHERE DEPTNO=20;
SAVEPOINT C2;
COMMIT;

DELETE FROM DEPT01
WHERE DEPTNO = 30; -- 이렇게 해서 DEPTNO :10 만 남음

ROLLBACK TO C2; -- C2지점으로 감
ROLLBACK TO C1; -- C1지점으로 (20,30지우기 전)
ROLLBACK; -- 그냥 롤백으로 감
-- SAVEPOINT 해놓으면 원하는 지점으로 되돌아 갈 수 있다.(대신 COMMIT이전으론 못가)
-- 여기서 SAVEPOINT 하고 커밋해도 SAVEPOINT로 못가 걍 커밋하면 이전으로 아에 못감.

SELECT * FROM EMP01
WHERE ENAME='SCOTT';

DELETE FROM EMP01
WHERE ENAME='SCOTT';
ROLLBACK;
-- 여기 말고 다른 사용자가 똑같은 자료에 손대고 나도 손대면 락에 걸림 그런경우 롤백 해줘야됨

SELECT * FROM EMP01;
SELECT SAL FROM EMP01
WHERE ENAME='SCOTT';

UPDATE EMP01 SET SAL=200
WHERE ENAME='SMITH';

COMMIT;

-- SET UNUSED
DROP TABLE EMP02;
CREATE TABLE EMP02
AS
SELECT * FROM EMP;

SELECT * FROM EMP02;

ALTER TABLE EMP02
SET UNUSED(COMM); -- 안보이게 숨기기
-- 이걸 왜쓰냐, 내가 안쓴다고 지워버리면 다른 사람들이 이 데이터를 작업할때 LOCK이 걸리는거
-- 그러니까 걍 지우지 말고 안보이게 해서 봐~

-- DDL 명령의 롤백
DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT * FROM EMP;
SELECT * FROM EMP01;

DROP TABLE EMP02;
CREATE TABLE EMP02
AS
SELECT * FROM EMP01;

ALTER TABLE EMP01
DROP COLUMN JOB; -- JOB 삭제됨
ROLLBACK; -- 롤백해도 안됨

DROP TABLE EMP01; -- 그래서 EMP01 없애버리고
RENAME EMP02 TO EMP01; -- EMP02의 이름을 EMP01로 변경

-- TRUNCATE와 DELETE의 차이
-- 둘다 테이블의 모든 행을 삭제한다. TRUNCATE = DELETE + COMMIT
DROP TABLE EMP01; 
CREATE TABLE EMP01
AS
SELECT * FROM EMP;
SELECT * FROM EMP01;
TRUNCATE TABLE EMP01; -- DDL 명령어로서 자동 커밋이 발생하기 때문에 이전으로 되돌릴 수 없다.
SELECT * FROM EMP01;
ROLLBACK;
SELECT * FROM EMP01; -- 복구 안돼
DROP TABLE EMP02;
CREATE TABLE EMP02
AS
SELECT * FROM EMP;
SELECT * FROM EMP02;
DELETE FROM EMP02; -- DML 명령어이기 때문에 롤백을 수행하면 삭제 이전으로 되돌릴 수 있다.
SELECT * FROM EMP02;
ROLLBACK;
SELECT * FROM EMP02; -- 복구 됨
DROP TABLE EMP03;
CREATE TABLE EMP03
AS
SELECT * FROM EMP;
SELECT * FROM EMP03;
DELETE FROM EMP03
WHERE DEPTNO>=10 OR DEPTNO=20;
SELECT * FROM EMP03;
COMMIT; -- 커밋 후에는 트랜잭션이 종료된 것이므로 롤백 이미지가 제거된다.
ROLLBACK; -- 따라서 삭제 이전 상태로 돌아갈 수 없다.
SELECT * FROM EMP03;
-- DELETE사용하는게 더 안전함.

SELECT * FROM EMP;
DESC EMP;
