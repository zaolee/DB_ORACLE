SELECT절 : 컬럼
FROM절 : 테이블
WHERE절 : 조건
ORDER BY절 : 정렬
GROUP BY절 : 그룹핑

JOIN

-- 복습
-- 형변환 함수 : TO_NUMBER, TO_CHAR, TO_DATE
-- 1. DATE -> VARCHAR2 ( 날짜 -> 문자)
SELECT SYSDATE 
FROM DUAL; 
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')"날짜를 문자로!" FROM DUAL; 
-- SYSDATE를 'YYYY-MM-DD'형식으로 바꾸고 싶어

-- 2. NUMBER -> VARCHAR2 (숫자 -> 문자)
SELECT ENAME, SAL FROM EMP;
SELECT ENAME, TO_CHAR(SAL, 'L999,999')"숫자를 문자로!" FROM EMP; 
-- 'L' : LOCALE(해당 PC에 로캘이 한국으로 되어 있기 때문에 \ 표시 생김), 시스템에 설정되어 있는 OS의 언어버전?

-- 3. NUMBER -> DATE (숫자 -> 날짜)
SELECT ENAME, HIREDATE FROM EMP;
SELECT ENAME, HIREDATE FROM EMP
-- WHERE HIREDATE = '1981/02/20';
WHERE HIREDATE = TO_DATE(19810110, 'YYYYMMDD');

-- 4. VARCHAR2 -> NUMBER (문자 -> 숫자)
SELECT TO_NUMBER('20,000', '99,999') - TO_NUMBER('10,000', '99,999')"문자를 숫자로!" FROM DUAL; -- 각각의 문자를 숫자로 바꿔준 다음에 산술

-- 22.12.14
-- SUM : 합계 구하기
SELECT SUM(SAL) FROM EMP;
SELECT SUM(COMM) FROM EMP; -- SUM()함수는  NULL을 제외시켜 합계한다.
SELECT COMM FROM EMP;

-- AVG : 평균 구하기
SELECT AVG(SAL) FROM EMP;
SELECT AVG(COMM) FROM EMP; -- AVG()함수도 NULL을 제외시켜 계산한다.

-- MAX / MIN : 최대 / 최소
SELECT MAX(SAL), MIN(SAL) FROM EMP;
SELECT SAL FROM EMP;

SELECT ENAME, MAX(SAL) FROM EMP; -- ENAME은 값이 여러개지만, 최댓값은 한 개라서 오류나 (not a single-group group function), 같이 쓸 수 없음

-- COUNT : 로우(ROW) 개수 구하기
SELECT COUNT(*), COUNT(COMM) FROM EMP;
SELECT COUNT(JOB) 업무수 FROM EMP; -- 중복 빼야됨(안빠짐)
SELECT COUNT(DISTINCT JOB) 업무수 FROM EMP; -- 중복 제거됨

-- GROUP BY 절
SELECT DEPTNO, AVG(SAL)급여평균
FROM EMP
GROUP BY DEPTNO; -- 그룹핑

SELECT DEPTNO, MAX(SAL)최대, MIN(SAL)최소
FROM EMP
WHERE SAL >= 800
GROUP BY DEPTNO
ORDER BY DEPTNO ASC;

-- HAVING 절 : GROUP의 조건을 준다.
SELECT DEPTNO, AVG(SAL)평균
FROM EMP
WHERE SAL >= 800 -- FROM에 대한 조건
GROUP BY DEPTNO
HAVING AVG(SAL) >= 2000 -- 전체 그룹핑 한것에 조건
ORDER BY DEPTNO ASC;
-- 순서 지켜주기!
-- 총 6개의 절로 구성

-- 집합 연산자
DROP TABLE EXP_GOODS_ASIA;

CREATE TABLE EXP_GOODS_ASIA (
    COUNTRY VARCHAR2(10),
    SEQ NUMBER,
    GOODS VARCHAR2(80)
);
DESC EXP_GOODS_ASIA;
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 1, '원유제외 석유류');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 2, '자동차');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 3, '전자집적회로');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 4, '선박');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 5, 'LCD');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 6, '자동차부품');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 7, '휴대전화');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 8, '환식탄화수소');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 9, '무선송신기 디스플레이 부속품');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 10, '철 또는 비합금강');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 1, '자동차');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 2, '자동차부품');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 3, '전자집적회로');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 4, '선박');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 5, '반도체웨이퍼');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 6, '화물차');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 7, '원유제외 석유류');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 8, '건설기계');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 9, '다이오드, 트랜지스터');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 10, '기계류');
COMMIT;

SELECT COUNT(*) FROM EXP_GOODS_ASIA;

SELECT GOODS
FROM EXP_GOODS_ASIA
WHERE COUNTRY = '한국'
ORDER BY SEQ;

SELECT GOODS
FROM EXP_GOODS_ASIA
WHERE COUNTRY = '일본'
ORDER BY SEQ;

-- UNION
SELECT GOODS
FROM EXP_GOODS_ASIA
WHERE COUNTRY = '한국'
UNION  -- 합집합
-- UNIONALL : 중복까지 다 더해버려
-- INTERSECT : 교집합
-- MINUS : 차집합
SELECT GOODS
FROM EXP_GOODS_ASIA
WHERE COUNTRY = '일본';

-- JOIN : 테이블과 테이블을 연결
SELECT * FROM EMP; -- 해당 사원의 부서명을  보려면 DEPT에 가서 봐야돼 -> 불편
SELECT * FROM DEPT;

SELECT DEPTNO FROM EMP
WHERE ENAME = 'SMITH';
SELECT DNAME FROM DEPT
WHERE DEPTNO = 20; -- 이렇게 핵 귀찮은 작업 + 두번보기 를 통해 'SMITH' 는 'RESEARCH'부서라는걸 알 수 잇음

SELECT EMP.ENAME, DEPT.DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO AND
EMP.ENAME = 'SMITH'; -- 이렇게 하면 한번에 볼수 있음

SELECT *
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO AND
EMP.ENAME = 'SMITH';  -- 두개의 테이블이 싹 JOIN됏어(하나의 테이블 처럼 사용할 수 있음), 관계형 데이타베이스(테이블들이 다 이어져있졍,,(DEPTNO))

-- ORACLE CROSS JOIN
SELECT * FROM EMP;
SELECT *
FROM EMP, DEPT
WHERE ENAME='SMITH'; -- 좀 쓸데없는거.. 같이 나와서 비추

SELECT * FROM DEPT;
COMMIT;
DELETE FROM DEPT
WHERE DEPTNO=50;

-- ORACLE EQUI JOIN
SELECT *
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO; -- 제일 정확하게 나와

SELECT EMP.ENAME, DEPT.DNAME, DEPT.DEPTNO -- ,DEPTNO column ambiguously defined : DEPTNO의 칼럼이 두개라 어떤걸 말하는지 몰라서 에러남. 정확하게 표현해주기
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO
AND ENAME='SCOTT';
-- 이름 너무 길어서 쓰기 귀찮을때
SELECT E.ENAME, D.DNAME, D.DEPTNO 
FROM EMP E, DEPT D -- 테이블에 별칭을 부여함
WHERE E.DEPTNO = D.DEPTNO
AND ENAME='SCOTT';

SELECT *
FROM EMP E, DEPT D 
WHERE E.DEPTNO = D.DEPTNO;

-- 1. 조인을 사용하여 뉴욕에서 근무하는 사원의 이름과 급여을 출력하세요.
SELECT E.ENAME, E.SAL
FROM EMP E, DEPT D 
WHERE E.DEPTNO = D.DEPTNO
AND LOC='NEW YORK'
ORDER BY ENAME ASC;

-- 2. 조인을 사용하여 ACCOUNTING 부서 소속 사원의 이름과 입사일을 출력하세요.
SELECT E.ENAME, E.HIREDATE, D.DNAME
FROM EMP E, DEPT D 
WHERE E.DEPTNO = D.DEPTNO
AND DNAME='ACCOUNTING'
ORDER BY ENAME ASC;

-- 3. 직급이 MANAGER인 사원의 이름, 부서명을 출력하세요.
SELECT E.ENAME, D.DNAME
FROM EMP E, DEPT D 
WHERE E.DEPTNO = D.DEPTNO
AND JOB='MANAGER'
ORDER BY ENAME ASC;

-- Non-Equi join
SELECT * FROM SALGRADE;

SELECT E.ENAME, E.SAL, S.GRADE
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;
-- WHERE E.SAL >=  S.LOSAL AND E.SAL <= S.HISAL; 이렇게도 표현 가능

-- SELF JOIN
SELECT EMPNO, ENAME, MGR FROM EMP;

SELECT E.ENAME 사원명, M.ENAME 상사명
FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO; -- 둘이 같은 수끼리 출력해죵

-- 1.매니저가 KING인 사원들의 이름과 직급을 출력하세요.
SELECT *
FROM EMP;

SELECT *
FROM DEPT;

SELECT E.ENAME 사원명, E.JOB 직급
FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO
AND M.ENAME='KING'
ORDER BY E.ENAME ASC;

-- 2. SCOTT과 동일한 근무지에서 근무하는 사원의 이름을 출력하세요.
SELECT E.ENAME 이름, C.ENAME 동료
FROM EMP E, EMP C
WHERE E.DEPTNO = C.DEPTNO
AND E.ENAME ='SCOTT'
AND C.ENAME <> 'SCOTT'
ORDER BY C.ENAME ASC;

-- OUTER JOIN : 조인 조건에 만족하지 못하였더라도 해당 로우를 나타내려고 할 때 사용한다.
SELECT E.ENAME, M.ENAME
FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO; -- KING이 안떠. 왜? -> 사장이라 매니저가 없걸랑(조건에 만족되지 않아)

SELECT E.ENAME, M.ENAME
FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO(+); -- KING 출력 돼

-- ANSI CROSS JOIN = ORACLE CROSS JOIN
-- ORACLE CROSS JOIN
SELECT *
FROM EMP, DEPT;

-- ANSI CROSS JOIN
SELECT *
FROM EMP CROSS JOIN DEPT;

-- ANSI Inner Join = ORACLE EQUI JOIN
-- ORACLE EQUI JOIN
SELECT E.ENAME, D.DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

-- ANSI Inner Join
SELECT E.ENAME, D.DNAME
FROM EMP E INNER JOIN DEPT D
--ON E.DEPTNO = D.DEPTNO;
USING(DEPTNO); -- 둘다 허용

-- ANSI NATUAL JOIN
SELECT E.ENAME, D.DNAME
FROM EMP E NATURAL JOIN DEPT D;

-- ANSI Outer Join
DROP TABLE DEPT01;

CREATE TABLE DEPT01(
    DEPTNO NUMBER(2),
    DNAME VARCHAR2(14)
);

INSERT INTO DEPT01 VALUES(10,'ACCOUNTING');
INSERT INTO DEPT01 VALUES(20,'RESEARCH');

SELECT *
FROM DEPT01;

DROP TABLE DEPT02;

CREATE TABLE DEPT02(
    DEPTNO NUMBER(2),
    DNAME VARCHAR2(14)
);

INSERT INTO DEPT02 VALUES(10,'ACCOUNTING');
INSERT INTO DEPT02 VALUES(30,'SALES');

SELECT *
FROM DEPT02;

-- ANSI Left Outer Join
SELECT *
FROM DEPT01 LEFT OUTER JOIN DEPT02
ON DEPT01.DEPTNO = DEPT02.DEPTNO;

-- ANSI Right Outer Join
SELECT *
FROM DEPT01 RIGHT OUTER JOIN DEPT02
USING(DEPTNO);

-- Full Outer Join
SELECT *
FROM DEPT01 FULL OUTER JOIN DEPT02
USING(DEPTNO);

-- 1. 직급이 MANAGER인 사원의 이름, 부서명을 출력하는 SQL문을 작성 하세요? (ORACLE EQUI JOIN, ANSI INNER JOIN, ANSI NATURAL JOIN을 사용하여 처리)
SELECT *
FROM EMP;

SELECT *
FROM DEPT;

SELECT E.ENAME 이름, D.DNAME 부서명
FROM EMP E INNER JOIN DEPT D
USING(DEPTNO)
WHERE E.JOB = 'MANAGER'
ORDER BY E.ENAME ASC; 

-- 2. SMITH와 동일한 직급(JOB컬럼)을 가진 사원의 이름과 직급을 출력하는 SQL문을 작성 하세요?

SELECT C.ENAME 이름, E.JOB 직급
FROM EMP E, EMP C
WHERE E.JOB = C.JOB
AND E.ENAME ='SMITH'
AND C.ENAME <> 'SMITH'
ORDER BY C.ENAME ASC;


